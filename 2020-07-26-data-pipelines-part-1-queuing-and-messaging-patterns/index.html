<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>Data Pipelines: Part 1 - Queuing and Messaging Patterns | Go (Golang) and Data Programming Blog - Nick Poorman</title><meta name=Description content="Current Data Pipelines are built using various queueing and messaging patterns. For the purpose of this blog post, I'm going to break them down into three categories by borrowing terms from ZeroMQ and others. The first two, Publish-Subscribe and Push-Pull are in-memory (volatile memory). The third, we'll call Streaming which is persisted on disk (non-volatile memory)."><meta property="og:title" content="Data Pipelines: Part 1 - Queuing and Messaging Patterns"><meta property="og:description" content="Current Data Pipelines are built using various queueing and messaging patterns. For the purpose of this blog post, I'm going to break them down into three categories by borrowing terms from ZeroMQ and others. The first two, Publish-Subscribe and Push-Pull are in-memory (volatile memory). The third, we'll call Streaming which is persisted on disk (non-volatile memory)."><meta property="og:type" content="article"><meta property="og:url" content="https://nickpoorman.com/2020-07-26-data-pipelines-part-1-queuing-and-messaging-patterns/"><meta property="og:image" content="https://nickpoorman.com/cover.png"><meta property="article:published_time" content="2020-07-26T08:00:00-05:00"><meta property="article:modified_time" content="2020-07-26T08:00:00-05:00"><meta property="og:site_name" content="Go (Golang) and Data Programming Blog - Nick Poorman"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://nickpoorman.com/cover.png"><meta name=twitter:title content="Data Pipelines: Part 1 - Queuing and Messaging Patterns"><meta name=twitter:description content="Current Data Pipelines are built using various queueing and messaging patterns. For the purpose of this blog post, I'm going to break them down into three categories by borrowing terms from ZeroMQ and others. The first two, Publish-Subscribe and Push-Pull are in-memory (volatile memory). The third, we'll call Streaming which is persisted on disk (non-volatile memory)."><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel=canonical href=https://nickpoorman.com/2020-07-26-data-pipelines-part-1-queuing-and-messaging-patterns/><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=prev href=https://nickpoorman.com/2020-03-01-forward/><link rel=next href=https://nickpoorman.com/2020-07-26-data-pipelines-part-2-retries/><link rel=stylesheet href=/css/style.min.min.6dddeb33532c40abe7cb958a84fb11dd7bec4f445f7b3f7dd1ec28e82974ff821055f15d1f4cc9387bf35326f0c7d46bec33e41df099253a7b19b5324fd44df0.css integrity="sha512-bd3rM1MsQKvny5WKhPsR3XvsT0Rfez990ewo6Cl0/4IQVfFdH0zJOHvzUybwx9Rr7DPkHfCZJTp7GbUyT9RN8A=="><link rel=preload href=/css/lib/fontawesome-free/all.min.min.c10b72e627916929312e76aae32cd871083b1a98e9603625bd9f45aedfa7fd382b9fe588affc4417ecfd42357214e2b1bdccd180b10a9f2bfc1dc42fdc3a6fd5.css integrity="sha512-wQty5ieRaSkxLnaq4yzYcQg7GpjpYDYlvZ9Frt+n/Tgrn+WIr/xEF+z9QjVyFOKxvczRgLEKnyv8HcQv3Dpv1Q==" as=style onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel=stylesheet href=/css/lib/fontawesome-free/all.min.min.c10b72e627916929312e76aae32cd871083b1a98e9603625bd9f45aedfa7fd382b9fe588affc4417ecfd42357214e2b1bdccd180b10a9f2bfc1dc42fdc3a6fd5.css integrity="sha512-wQty5ieRaSkxLnaq4yzYcQg7GpjpYDYlvZ9Frt+n/Tgrn+WIr/xEF+z9QjVyFOKxvczRgLEKnyv8HcQv3Dpv1Q=="></noscript><link rel=preload href=/css/lib/lightbox/lightbox.min.min.b999b8d703e46e94fdff333f191b7fbe43aea06dc495e4b8243060e495f4c42bba68935cdcfd0a02a4b843102ae909feebfb244a01f82ce3c17ec00a778a5dba.css integrity="sha512-uZm41wPkbpT9/zM/GRt/vkOuoG3EleS4JDBg5JX0xCu6aJNc3P0KAqS4QxAq6Qn+6/skSgH4LOPBfsAKd4pdug==" as=style onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel=stylesheet href=/css/lib/lightbox/lightbox.min.min.b999b8d703e46e94fdff333f191b7fbe43aea06dc495e4b8243060e495f4c42bba68935cdcfd0a02a4b843102ae909feebfb244a01f82ce3c17ec00a778a5dba.css integrity="sha512-uZm41wPkbpT9/zM/GRt/vkOuoG3EleS4JDBg5JX0xCu6aJNc3P0KAqS4QxAq6Qn+6/skSgH4LOPBfsAKd4pdug=="></noscript><meta name=p:domain_verify content="e820434c419f4c0782c7916de63ecb60"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Data Pipelines: Part 1 - Queuing and Messaging Patterns","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/nickpoorman.com\/2020-07-26-data-pipelines-part-1-queuing-and-messaging-patterns\/"},"image":{"@type":"ImageObject","url":"https:\/\/nickpoorman.com\/cover.png","width":1200,"height":628},"genre":"posts","keywords":"Golang, Data, Queuing, Messaging Patterns","wordcount":1997,"url":"https:\/\/nickpoorman.com\/2020-07-26-data-pipelines-part-1-queuing-and-messaging-patterns\/","datePublished":"2020-07-26T08:00:00-05:00","dateModified":"2020-07-26T08:00:00-05:00","publisher":{"@type":"Organization","name":"Nick Poorman","logo":{"@type":"ImageObject","url":"https:\/\/nickpoorman.com\/logo.png","width":127,"height":40}},"description":"Current Data Pipelines are built using various queueing and messaging patterns. For the purpose of this blog post, I\x27m going to break them down into three categories by borrowing terms from ZeroMQ and others. The first two, Publish-Subscribe and Push-Pull are in-memory (volatile memory). The third, we\x27ll call Streaming which is persisted on disk (non-volatile memory)."}</script></head><body><script>if(!window.localStorage||!window.localStorage.getItem('theme')){window.isDark=window.matchMedia('(prefers-color-scheme: dark)').matches;}else{window.isDark=(window.localStorage&&window.localStorage.getItem('theme'))==='dark';}
window.isDark&&document.body.classList.add('dark-theme');</script><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/>Intersection of Go and Data</a></div><div class=menu><a class=menu-item href=/posts/ title="list of blog posts">Posts</a><a class=menu-item href=/tags/ title="list of article tags">Tags</a><a class=menu-item href=/about/ title="Nick Poorman about page">About</a><a href=javascript:void(0); class=theme-switch title="Switch website theme to Dark mode" aria-label="Switch website theme to Dark mode">
<i class="fas fa-adjust fa-rotate-180 fa-fw"></i></a></div></div></header><header class=mobile id=header-mobile><div class=header-wrapper><div class=header-container><div class=header-title><a href=/>Intersection of Go and Data</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title="list of blog posts">Posts</a><a class=menu-item href=/tags/ title="list of article tags">Tags</a><a class=menu-item href=/about/ title="Nick Poorman about page">About</a><a href=javascript:void(0); class=theme-switch title="Switch website theme to Dark mode" aria-label="Switch website theme to Dark mode">
<i class="fas fa-adjust fa-rotate-180 fa-fw"></i></a></div></div></header><script>window.desktopHeaderMode="fixed";window.mobileHeaderMode="auto";</script><main class=main><div class=container><article class="page single"><h1 class=single-title>Data Pipelines: Part 1 - Queuing and Messaging Patterns</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a class=author href=/ rel=author target=_blank><i class="fas fa-user-circle fa-fw"></i>Nick Poorman</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i><time datetime=2020-07-26>2020-07-26</time>&nbsp;
<i class="fas fa-pencil-alt fa-fw"></i>about 1997 words&nbsp;
<i class="far fa-clock fa-fw"></i>10 min&nbsp;</div></div><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><div class=toc id=toc-static><details><summary><div class=toc-title><span>Contents</span>
<span><i class="details icon fas fa-angle-down"></i></span></div></summary><div class=toc-content id=toc-content-static><nav id=TableOfContents><ul><li><ul><li><a href=#publish-subscribe>Publish-Subscribe</a></li><li><a href=#push-pull>Push-Pull</a></li><li><a href=#streaming>Streaming</a></li><li><a href=#kinesis-kafka-google-pubsub-zeromq-nsq-redis-streams->Kinesis, Kafka, Google PubSub, ZeroMQ, NSQ, Redis Streams, &mldr;</a></li><li><a href=#data-pipelines-and-back-pressure>Data Pipelines and Back Pressure</a></li><li><a href=#consuming>Consuming</a></li><li><a href=#webhook-downtime>Webhook Downtime</a></li><li><a href=#up-next>Up Next</a></li></ul></li></ul></nav></div></details></div><div class=content><p>Current Data Pipelines are built using various queueing and messaging patterns. For the purpose of this blog post, I&rsquo;m going to break them down into three categories by borrowing terms from <a href=http://zguide.zeromq.org/page:all target=_blank rel="noopener noreffer">ZeroMQ</a>
and others. The first two, Publish-Subscribe and Push-Pull are in-memory (volatile memory). The third, we&rsquo;ll call Streaming which is persisted on disk (non-volatile memory).</p><h3 id=publish-subscribe>Publish-Subscribe</h3><p>Publish-Subscribe (pub-sub), is a messaging pattern where producers (publishers) send messages to consumers (subscribers). Pub-sub allows publishers and subscribers to communicate without being tightly coupled. A publisher may publish messages to any number of topics, and a subscriber may selectively decide from which of those topics they would like to receive messages. Topics (sometimes referred to as subjects), are a way of grouping messages together and provide a means for subscribers to receive only the messages they are interested in while ignoring everything else.</p><p><figure><img src=/svg/loading.min.svg data-sizes=auto data-src=pub-sub.svg alt="Diagram of Publish-Subscribe" title="Diagram of Publish-Subscribe" class=lazyload><figcaption class=image-caption>Diagram of Publish-Subscribe</figcaption></figure></p><p>Often publishers do not send messages directly to subscribers but instead send the messages through a relay, known as a broker. The broker, upon receiving a message to a topic from a publisher, will forward the message to all subscribers of that topic. If no subscribers are listening when a message is published, the message simply evaporates. This also means publishers can send the messages at any rate they choose, and the subscribers must keep up.</p><p><figure><img src=/svg/loading.min.svg data-sizes=auto data-src=pub-sub-broker.svg alt="Diagram of Publish-Subscribe With Broker" title="Diagram of Publish-Subscribe With Broker" class=lazyload><figcaption class=image-caption>Diagram of Publish-Subscribe With Broker</figcaption></figure></p><h3 id=push-pull>Push-Pull</h3><p>Push-Pull, on the other hand, is similar to publish-subscribe in that publishers &ldquo;push&rdquo; a message into a queue, and the subscribers must request to pull the messages out. In Go, an unbuffered channel is essentially push-pull with a queue size of zero. The benefit here is that subscribers can control the rate at which they would like to receive the messages by explicitly requesting to pull messages at their own pace. The downside here is that if the publishers are producing data faster than the subscribers (the pullers) are requesting to consume it, you may run out of memory or resort to spilling messages to disk (in many cases improperly spilling to a slow swap partition).</p><p><figure><img src=/svg/loading.min.svg data-sizes=auto data-src=push-pull.svg alt="Diagram of Push-Pull" title="Diagram of Push-Pull" class=lazyload><figcaption class=image-caption>Diagram of Push-Pull</figcaption></figure></p><h3 id=streaming>Streaming</h3><p>Streaming is a concept built on top of push-pull. I&rsquo;m referring to it as Streaming for lack of a better term (please reach out if you have one). Streaming tries to solve the downside of pub-sub and push-pull running out of memory. When either the producer or consumer is faster than the other, Streaming will queue up the messages on disk. Technologies such as Kafka attempt to horizontally scale this concept by distributing around a log of messages on disk.</p><p><figure><img src=/svg/loading.min.svg data-sizes=auto data-src=streaming.svg alt="Diagram of Streaming" title="Diagram of Streaming" class=lazyload><figcaption class=image-caption>Diagram of Streaming</figcaption></figure></p><h3 id=kinesis-kafka-google-pubsub-zeromq-nsq-redis-streams->Kinesis, Kafka, Google PubSub, ZeroMQ, NSQ, Redis Streams, &mldr;</h3><p>Over the last few years, it seems like the number of messaging systems created could rival the number of new JavaScript frameworks. The messaging systems essentially solve the same problem but abstract away different parts of the system by providing slightly different guarantees.</p><p>The main takeaway here is that no matter which system you consider, at their core, they either choose to keep messages in-memory or on-disk, and they choose to give you control of the publisher rate or the subscriber rate. That&rsquo;s not to say there isn&rsquo;t a happy middle-ground. If you look at protocols such as <a href=https://en.wikipedia.org/wiki/Sliding_window_protocol target=_blank rel="noopener noreffer">TCP sliding windows</a>
, you&rsquo;ll see that the producer and consumer can negotiate to establish a rate in which to produce and consume messages. Looking closer at TCP, you&rsquo;ll also notice a concept of <a href=https://tools.ietf.org/html/rfc793#section-1.5 target=_blank rel="noopener noreffer">acknowledging messages for reliability</a>
, referred to as an ACK. Acknowledgment can be used to provide feedback from the consumer to the producer that a message was received. They can also be used to tell the producer to slow down if, for some reason, the consumer can&rsquo;t keep up. UDP, on the other hand, simply emits packets from a source and doesn&rsquo;t care if they arrive at the destination or the rate at which they arrive at the destination. UDP is similar to publish-subscribe in this sense.</p><h3 id=data-pipelines-and-back-pressure>Data Pipelines and Back Pressure</h3><p>In the case of Data Pipelines, you often are not able to control the producer rate, but you can control the consumer rate. This is because your producers are often users. For example, think about a Data Pipeline that must consume messages from every user that visits your website. Each page visit by a user produces a message so that later you can sum the number of times a given page was visited. With the scale of the web today, it&rsquo;s possible a page could become viral, and users visiting the page would quickly generate hundreds of millions of messages to your Data Pipeline. You wouldn&rsquo;t want to control the backpressure by telling visitors to stop visiting your site, and you certainly wouldn&rsquo;t want to try drinking directly from a fire hydrant by putting your mouth up to it. So instead, you opt to choose a technology where you control the consumer rate.</p><p>This is where Streaming comes in, and technologies such as Kinesis, Kafka, Google PubSub, etc.. begin building mountains of marketing material. Now you purchase a wonderful streaming technology, your users (the fire hydrants) can send messages as quickly as they please. Your Streaming technology accepts the messages and persists them out to disk (most likely) until they are ready to be consumed by you. All is right in the world. Now it&rsquo;s up to you to build a consumer.</p><h3 id=consuming>Consuming</h3><p>Your Streaming technology is up and running, and your users are firing messages at unbounded rates. You want to build a consumer that pulls messages from your Streaming technology and totals up the times each page was visited. That should be simple enough. You write a small program that in a loop, pulls a message from your Streaming technology, looks at what page the message belongs to, and increments a counter. Maybe in the middle of the night, the traffic for your viral page begins to subside. All the while working at its own pace, your consumer continued to pull every message from your Streaming technology. It&rsquo;s has caught up to the rate of the messages being produced. You sit down at your computer in the morning and gaze over the glorious number of page views you received.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-json data-lang=json><span class=p>{</span>
  <span class=nt>&#34;visitTimestamp&#34;</span><span class=p>:</span> <span class=s2>&#34;2020-07-14T18:47:13.919Z&#34;</span><span class=p>,</span>
  <span class=nt>&#34;page&#34;</span><span class=p>:</span> <span class=s2>&#34;/blog/data-pipeline-queuing-and-messaging-patterns&#34;</span><span class=p>,</span>
  <span class=nt>&#34;publishedTimestamp&#34;</span><span class=p>:</span> <span class=s2>&#34;2020-07-14T08:00:00.000Z&#34;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=nx>totalPageViews</span> <span class=kt>int64</span>
<span class=k>for</span> <span class=p>{</span>
    <span class=nx>msg</span> <span class=o>:=</span> <span class=nf>pullMessageFromStreamingTechnology</span><span class=p>()</span>

    <span class=c1>// Increment our page views
</span><span class=c1></span>    <span class=nx>totalPageViews</span><span class=o>++</span>

    <span class=c1>// Tell streaming technology we processed the message
</span><span class=c1></span>    <span class=c1>// so that it can remove it from disk.
</span><span class=c1></span>    <span class=nx>msg</span><span class=p>.</span><span class=nf>Acknowledge</span><span class=p>()</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Imagine some time has passed, and after a while, you notice that the time of day you post new content to a page seems to have some correlation to how viral the page becomes. So you decided to pay for <a href=https://segment.com/catalog/ target=_blank rel="noopener noreffer">Saas analysis tools</a>
to determine the best time of day to publish new content. In order for the SaaS analysis tool to do its job, you must forward the events you receive from your users to the SaaS analysis tool. That way, the SaaS analysis tool can correlate the time you publish your articles to the time of the visits, thus telling you when the best time to publish is. How should we do this? One way is to hook into the consumer totaling up the number of page views. In addition to totaling the page views, we&rsquo;ll make it responsible for forwarding the message off to the SaaS analysis tool&rsquo;s <a href=https://keen.io/docs/streams/extended-functionality/webhooks-integration/ target=_blank rel="noopener noreffer">webhook</a>
endpoint.</p><p><figure><img src=/svg/loading.min.svg data-sizes=auto data-src=saas-webhook.svg alt="Diagram of a SaaS Webhook" title="Diagram of a SaaS Webhook" class=lazyload><figcaption class=image-caption>Diagram of a SaaS Webhook</figcaption></figure></p><h3 id=webhook-downtime>Webhook Downtime</h3><p>Like every service on the Internet, the SaaS analysis tool will experience downtime, and the webhook your Streaming technology consumer is forwarding messages to will stop responding. Maybe the SaaS analysis tool will be deploying an API update, or there will be a <a href="https://news.ycombinator.com/item?id=23897705" target=_blank rel="noopener noreffer">widespread internet outage</a>
, causing the webhook to be offline for a significant amount of time. In the meantime, your consumer will stop making any progress because it continues to receive an error when trying to forward the message to the SaaS analysis tool&rsquo;s webhook.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=nx>totalPageViews</span> <span class=kt>int64</span>
<span class=k>for</span> <span class=p>{</span>
    <span class=nx>msg</span> <span class=o>:=</span> <span class=nf>pullMessageFromStreamingTechnology</span><span class=p>()</span>

    <span class=nx>err</span> <span class=o>:=</span> <span class=nf>sendMessageToAnalysisSaaSWebhook</span><span class=p>(</span><span class=nx>msg</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=p>{</span>
        <span class=c1>// SaaS analysis tool isn&#39;t accepting messges right now;
</span><span class=c1></span>        <span class=c1>// probably because they don&#39;t have a redundant streaming technology.
</span><span class=c1></span>        <span class=c1>//
</span><span class=c1></span>        <span class=c1>// Don&#39;t acknowledge the message and try again.
</span><span class=c1></span>        <span class=c1>// Our Streaming Technology will return the same message to us again
</span><span class=c1></span>        <span class=c1>// on the next iteration of the loop when we ask for it.
</span><span class=c1></span>        <span class=k>continue</span>
    <span class=p>}</span>

    <span class=c1>// Increment our page views
</span><span class=c1></span>    <span class=nx>totalPageViews</span><span class=o>++</span>

    <span class=c1>// Tell streaming technology we processed the message
</span><span class=c1></span>    <span class=c1>// so that it can remove it from disk.
</span><span class=c1></span>    <span class=nx>msg</span><span class=p>.</span><span class=nf>Acknowledge</span><span class=p>()</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Is there something we can do here so that our consumer may continue pulling messages from our Streaming technology? We would really like to be able to ignore the fact the SaaS analysis tool is offline and continue totaling our page views to see what the total is. However, we can&rsquo;t permanently skip over messages we processed while the SaaS analysis tool was offline. We would need the messages to be delivered to the SaaS analysis tool when it comes back online.</p><p>What are some things we could do here? One option is for us to spend more money and buy a second Streaming technology (or buy one that allows for multiple topics) and place it in between our existing Streaming technology consumer and the SaaS analysis tool webhook.</p><p><figure><img src=/svg/loading.min.svg data-sizes=auto data-src=saas-webhook-streaming.svg alt="Diagram of a SaaS Webook With Streaming" title="Diagram of a SaaS Webook With Streaming" class=lazyload><figcaption class=image-caption>Diagram of a SaaS Webook With Streaming</figcaption></figure></p><p>When consumer-1 pulls messages off streaming-1, it will push the message to streaming-2 and then increment the total page views. Consumer-2 can now pull messages from streaming-2 at its own pace. This means when SaaS Webhook is offline, consumer-2 isn&rsquo;t making any progress, but that shouldn&rsquo;t matter because it doesn&rsquo;t stop us from totaling up our page views. Once SaaS Webhook is back online, consumer-2 will send all the messages that arrived at streaming-2 while SaaS Webhook was offline.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// consumer-1
</span><span class=c1></span><span class=kd>var</span> <span class=nx>totalPageViews</span> <span class=kt>int64</span>
<span class=k>for</span> <span class=p>{</span>
    <span class=nx>msg</span> <span class=o>:=</span> <span class=nf>pullMessageFromStreaming1</span><span class=p>()</span>

    <span class=nf>sendMessageToStreaming2</span><span class=p>(</span><span class=nx>msg</span><span class=p>)</span>

    <span class=c1>// Increment our page views
</span><span class=c1></span>    <span class=nx>totalPageViews</span><span class=o>++</span>

    <span class=c1>// Tell streaming technology we processed the message
</span><span class=c1></span>    <span class=c1>// so that it can remove it from disk.
</span><span class=c1></span>    <span class=nx>msg</span><span class=p>.</span><span class=nf>Acknowledge</span><span class=p>()</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// consumer-2
</span><span class=c1></span><span class=k>for</span> <span class=p>{</span>
    <span class=nx>msg</span> <span class=o>:=</span> <span class=nf>pullMessageFromStreaming2</span><span class=p>()</span>

    <span class=nx>err</span> <span class=o>:=</span> <span class=nf>sendMessageToAnalysisSaaSWebhook</span><span class=p>(</span><span class=nx>msg</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=p>{</span>
        <span class=c1>// SaaS analysis tool isn&#39;t accepting messges right now;
</span><span class=c1></span>        <span class=c1>// probably because they don&#39;t have a redundant streaming technology.
</span><span class=c1></span>        <span class=c1>//
</span><span class=c1></span>        <span class=c1>// Don&#39;t acknowledge the message and try again.
</span><span class=c1></span>        <span class=c1>// Our Streaming Technology will return the same message to us again
</span><span class=c1></span>        <span class=c1>// on the next iteration of the loop when we ask for it.
</span><span class=c1></span>        <span class=k>continue</span>
    <span class=p>}</span>

    <span class=c1>// Tell streaming technology we processed the message
</span><span class=c1></span>    <span class=c1>// so that it can remove it from disk.
</span><span class=c1></span>    <span class=nx>msg</span><span class=p>.</span><span class=nf>Acknowledge</span><span class=p>()</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Additionally, this solution would solve any rate limiting SaaS Webhook may have in place. Most SaaS APIs set a limit on the maximum number of requests a single customer can make to it in a given time period so that a single customer cannot overload the API. In the solution above, because consumer-2 is able to pull messages from streaming-2 at it&rsquo;s own pace, consumer-2 can respect the SaaS Webhook rate limit by setting the pace equal to that of the rate limit.</p><h3 id=up-next>Up Next</h3><p>Hopefully, now you can see how combining various queuing and messaging patterns such as pub-sub, push-pull, and streaming allows you to build resilient data pipelines. Given the solution above for sending messages to a webhook we don&rsquo;t control, you might be thinking that adding another set of streaming and consumer components for every additional webhook could get rather unwieldy. <a href=/2020-07-26-data-pipelines-part-2-retries/ rel="noopener noreffer">In the next post</a>
, I&rsquo;ll be going over an alternative solution that tries to address the amount of duplicate streaming and consumer components that would be necessary.</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>The article was updated on 2020-07-26</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=https://nickpoorman.com/2020-07-26-data-pipelines-part-1-queuing-and-messaging-patterns/index.md target=_blank>Read Markdown</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://nickpoorman.com/2020-07-26-data-pipelines-part-1-queuing-and-messaging-patterns/ data-title="Data Pipelines: Part 1 - Queuing and Messaging Patterns" data-via=nickpoorman data-hashtags="Golang,Data,Queuing,Messaging Patterns"><i class="fab fa-twitter fa-fw"></i></a><a href=javascript:void(0); title="Share on Linkedin" data-sharer=linkedin data-url=https://nickpoorman.com/2020-07-26-data-pipelines-part-1-queuing-and-messaging-patterns/><i class="fab fa-linkedin fa-fw"></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=https://nickpoorman.com/2020-07-26-data-pipelines-part-1-queuing-and-messaging-patterns/ data-title="Data Pipelines: Part 1 - Queuing and Messaging Patterns"><i class="fab fa-hacker-news fa-fw"></i></a><a href=javascript:void(0); title="Share on Reddit" data-sharer=reddit data-url=https://nickpoorman.com/2020-07-26-data-pipelines-part-1-queuing-and-messaging-patterns/><i class="fab fa-reddit fa-fw"></i></a></span></div></div></div><div class=post-info-more><section><span><a href=/tags/golang><i class="fas fa-tag fa-fw"></i>Golang</a>
</span>&nbsp;<span>
<a href=/tags/data><i class="fas fa-tag fa-fw"></i>Data</a>
</span>&nbsp;<span>
<a href=/tags/queuing><i class="fas fa-tag fa-fw"></i>Queuing</a>
</span>&nbsp;<span>
<a href=/tags/messaging-patterns><i class="fas fa-tag fa-fw"></i>Messaging Patterns</a>
</span>&nbsp;</section><section><span><a href=javascript:window.history.back();>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=https://nickpoorman.com/2020-03-01-forward/ class=prev rel=prev title=Forward><i class="fas fa-angle-left fa-fw"></i>Forward</a>
<a href=https://nickpoorman.com/2020-07-26-data-pipelines-part-2-retries/ class=next rel=next title="Data Pipelines: Part 2 - Retries">Data Pipelines: Part 2 - Retries<i class="fas fa-angle-right fa-fw"></i></a></div></div><div class=comment></div></article></div></main><footer class=footer><div class=copyright><div class=copyright-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2020</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>Nick Poorman</a></span></div></div></footer></div><a href=# class="dynamic-to-top animated faster" id=dynamic-to-top><span>&nbsp;</span>
</a><script>function _loadKatex(){}</script><script async src=/js/bundle-scriptLocal.min.9c14e4a929cb9597b5f98895cce6ed350edb633e3ce7f2bf5b8949ea9106e7bf8e7b540145bd24582018941f470378e9c3f76bb8f747d8f181fdee129509300a.js integrity="sha512-nBTkqSnLlZe1+YiVzObtNQ7bYz485/K/W4lJ6pEG57+Oe1QBRb0kWCAYlB9HA3jpw/druPdH2PGB/e4SlQkwCg=="></script><script async defer data-domain=nickpoorman.com src=https://st.nickpoorman.com/js/index.js></script></body></html>