<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Messaging Patterns on Go (Golang) and Data Programming Blog - Nick Poorman</title><link>https://nickpoorman.com/tags/messaging-patterns/</link><description>Recent content in Messaging Patterns on Go (Golang) and Data Programming Blog - Nick Poorman</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 26 Jul 2020 12:00:00 -0500</lastBuildDate><atom:link href="https://nickpoorman.com/tags/messaging-patterns/index.xml" rel="self" type="application/rss+xml"/><item><title>Data Pipelines: Part 2 - Retries</title><link>https://nickpoorman.com/2020-07-26-data-pipelines-part-2-retries/</link><pubDate>Sun, 26 Jul 2020 12:00:00 -0500</pubDate><guid>https://nickpoorman.com/2020-07-26-data-pipelines-part-2-retries/</guid><description>Building a cloud-scale central retry service for Data Pipelines.</description></item><item><title>Data Pipelines: Part 1 - Queuing and Messaging Patterns</title><link>https://nickpoorman.com/2020-07-26-data-pipelines-part-1-queuing-and-messaging-patterns/</link><pubDate>Sun, 26 Jul 2020 08:00:00 -0500</pubDate><guid>https://nickpoorman.com/2020-07-26-data-pipelines-part-1-queuing-and-messaging-patterns/</guid><description>Current Data Pipelines are built using various queueing and messaging patterns. For the purpose of this blog post, I&amp;rsquo;m going to break them down into three categories by borrowing terms from ZeroMQ and others. The first two, Publish-Subscribe and Push-Pull are in-memory (volatile memory). The third, we&amp;rsquo;ll call Streaming which is persisted on disk (non-volatile memory).</description></item></channel></rss>